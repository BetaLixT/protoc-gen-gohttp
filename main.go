package main

import (
	"fmt"
	"unicode"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	protogen.Options{}.Run(func(p *protogen.Plugin) error {
		for _, f := range p.Files {
			if f.Generate {
				if err := GenerateFile(p, f); err != nil {
					return err
				}
			}
		}

		return nil
	})
}

func GenerateFile(
	plugin *protogen.Plugin,
	file *protogen.File,
) error {
	isGenerated := false
	for _, srv := range file.Services {
		for _, method := range srv.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			isGenerated = true
		}
	}

	if !isGenerated {
		return nil
	}
	plugin.SupportedFeatures = 1

	filename := file.GeneratedFilenamePrefix + ".http.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-gohttp. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)

	// imports
	g.P("import (")
	g.P("\t\"context\"")
	g.P("\t\"github.com/gin-gonic/gin\"")
	g.P(")")

	for _, srv := range file.Services {
		// if err := genService(g, srv); err != nil {
		// 	return err
		// }
		intname := srv.GoName + "HTTPServer"
		g.P(fmt.Sprintf("// %s", srv.GoName))
		g.P("type ", intname, " interface {")
		for _, rpc := range srv.Methods {
			g.Write([]byte(rpc.Comments.Leading.String()))
			g.P("\t", rpc.GoName, "(context.Context, *", rpc.Input.GoIdent.GoName, ") (*", rpc.Output.GoIdent.GoName, ", error)")
			g.Write([]byte(rpc.Comments.Trailing.String()))
		}
		g.P("}")

		// controllers
		// TODO: handling get requests and path parameters
		ctrlName := toLower(srv.GoName)
		g.P("type ", ctrlName, " struct {")
		g.P("app ", intname)
		g.P("}")

		reqs := []request{}
		for _, rpc := range srv.Methods {
			options, ok := rpc.Desc.Options().(*descriptorpb.MethodOptions)
			if !ok {
				return nil
			}

			httpRule, ok := proto.GetExtension(options, annotations.E_Http).(*annotations.HttpRule)
			if !ok {
				return nil
			}

			req := request{
				Method:  "",
				Path:    "",
				Handler: toLower(rpc.GoName),
			}

			switch httpRule.GetPattern().(type) {
			case *annotations.HttpRule_Get:
				req.Method = "GET"
				req.Path = httpRule.GetGet()
			case *annotations.HttpRule_Put:
				req.Method = "PUT"
				req.Path = httpRule.GetPut()
			case *annotations.HttpRule_Post:
				req.Method = "POST"
				req.Path = httpRule.GetPost()
			case *annotations.HttpRule_Delete:
				req.Method = "DELETE"
				req.Path = httpRule.GetDelete()
			case *annotations.HttpRule_Patch:
				req.Method = "PATCH"
				req.Path = httpRule.GetPatch()
			default:
				continue
			}
			reqs = append(reqs, req)
			g.P("func (p *", ctrlName, ")", toLower(rpc.GoName), "(ctx *gin.Context) {")

			g.P("body := ", rpc.Input.GoIdent.GoName, "{}")
			g.P("ctx.BindJSON(&body)")
			g.P("p.app.", rpc.GoName, "(")
			g.P("ctx,")
			g.P("&body,")
			g.P(")")
			g.P("}")
		}

		g.P("func Register", srv.GoName, "HTTPServer (")
		g.P("grp *gin.RouterGroup,")
		g.P("srv ", intname, ",")
		g.P(") {")
		g.P("ctrl := ", ctrlName, "{app: srv}")
		for _, r := range reqs {
			g.P("grp.", r.Method, "(\"", r.Path, "\", ", "ctrl.", r.Handler, ")")
		}
		g.P("}")
	}

	return nil
}

// func (ctrl *GroupsController) RegisterRoutes(grp *gin.RouterGroup) {
// 	grp.POST("/groups/callback", ctrl.handleGroupChange)
// }

type request struct {
	Method  string
	Path    string
	Handler string
}

func toLower(in string) (out string) {
	inr := []rune(in)
	inr[0] = unicode.ToLower(inr[0])
	out = string(inr)
	return
}
